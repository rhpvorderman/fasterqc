# This file contains subsequences of common adapters
# Keep in mind that the implementation stores adapters in a 64-bit word so
# the runtime increases when the combined length of the adapters exceeds
# 64. For this reason length 12 is chosen, so we can fit 5 adapters in a
# single word.

Illumina Universal Adapter	AGATCGGAAGAG
Illumina Small RNA 3' adapter	TGGAATTCTCGG
Illumina Small RNA 5' adapter	GATCGTCGGACT

Nextera Transposase Sequence	CTGTCTCTTATA

PolyA	AAAAAAAAAAAA
PolyG	GGGGGGGGGGGG

Oxford nanopore strand switching primer (SSP or SSPII) or CDNA primer, reverse sequence	TTTCTGTTGGTG
Oxford nanopore RT primer, VN primer, or CDNA primer, forward sequence	CTTGCCTGTCGC
Oxford nanopore ligation kit, rapid adapter or Adapter Mix (AMX); all top strand	TGTACTTCGTTC
Oxford nanopore ligation kit or Adapter Mix; both bottom strand	GCAATACGTAAC
Oxford nanopore RT adapter (RTA) or RNA adapter mix (RMX); both bottom strand	GAGGCGAGCGGT
# Use TTTTTTTTTTTAT rather than TTTTTTTTTTTT to avoid double hit for VN primer.
Oxford nanopore RNA Adapter Mix (RMX); top strand	TTTTTTTTTTTAT
OXford nanopore RT Adapter (RTA); top strand	GGCTTCTTCTTG
Oxford nanopore cDNA RT Adapter (CRT)	CTTGCGGGCGGC


# Most common subsequences for nanopore found with the following code:

# from collections import defaultdict
#
# from sequali.util import fasta_parser
#
#
# if __name__ == "__main__":
#     k = 12
#     kmers_and_names = defaultdict(set)
#     for name, sequence in fasta_parser("src/sequali/contaminants/oxford_nanopore.fasta"):
#         number_of_kmers = len(sequence) + 1 - k
#         for i in range(number_of_kmers):
#             kmer = sequence[i:i+k]
#             kmers_and_names[kmer].add(name)
#     items = list(kmers_and_names.items())
#     items.sort(key=lambda x: len(x[1]), reverse=True)
#     for kmer, names in items:
#         if len(names) == 1:
#             continue
#         print(f"{kmer}: {', '.join(names)}")
